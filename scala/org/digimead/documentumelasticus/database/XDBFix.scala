/*
 *
 * This file is part of the Documentum Elasticus project.
 * Copyright (c) 2010-2011 Limited Liability Company «MEZHGALAKTICHESKIJ TORGOVYJ ALIANS»
 * Author: Alexey Aksenov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Global License version 3
 * as published by the Free Software Foundation with the addition of the
 * following permission added to Section 15 as permitted in Section 7(a):
 * FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED
 * BY Limited Liability Company «MEZHGALAKTICHESKIJ TORGOVYJ ALIANS»,
 * Limited Liability Company «MEZHGALAKTICHESKIJ TORGOVYJ ALIANS» DISCLAIMS
 * THE WARRANTY OF NON INFRINGEMENT OF THIRD PARTY RIGHTS.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Global License for more details.
 * You should have received a copy of the GNU Affero General Global License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA, 02110-1301 USA, or download the license from the following URL:
 * http://www.gnu.org/licenses/agpl.html
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Global License.
 *
 * In accordance with Section 7(b) of the GNU Affero General Global License,
 * you must retain the producer line in every report, form or document
 * that is created or manipulated using Documentum Elasticus.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the Documentum Elasticus software without
 * disclosing the source code of your own applications.
 * These activities include: offering paid services to customers,
 * serving files in a web or/and network application,
 * shipping Documentum Elasticus with a closed source product.
 *
 * For more information, please contact Documentum Elasticus Team at this
 * address: ezh@ezh.msk.ru
 *
 */

package org.digimead.documentumelasticus.database

import java.sql.Connection
import org.digimead.documentumelasticus.helper._

trait XDBFix extends XDBUtils {
  def fixDataSource(connection: Connection): Boolean = {
    var result: Boolean = true
    val statement = connection.createStatement()
    val md = connection.getMetaData()

    logger.info("check database version")
    /*
     * METADATA
     */
    val sTable = addTablePrefix("METADATA")
    val rs = md.getTables(null, null, sTable, Array("TABLE"))
    if (!rs.next()) {
      var sCreateStatement = "CREATE TABLE METADATA\n"
      sCreateStatement += "(\"KEY\" VARCHAR_IGNORECASE(1024) PRIMARY KEY,\n"
      sCreateStatement += "\"VALUE\" VARCHAR(1024))"
      if (!createTable(connection, sCreateStatement, sTable))
        return false
      statement.executeUpdate("INSERT INTO METADATA VALUES ('VERSION','0')")
    }
    rs.close()
    statement.close()
    /*
     * VERSION
     */
    val version = selectRow(connection, "SELECT VALUE FROM METADATA WHERE KEY='VERSION'")(0).asInstanceOf[String]
    logger.warn("database version: " + version)
    /*
     * FIXES
     */
    if (version.toInt < 20110110)
      result = fixDataSourceNullTo20110209(connection)
    /*
     * REFRESH
     */
    // TODO refresh ODB
    /*val refresh = O.I[XRefreshable](xDBTables.getTables())
    refresh.refresh()*/
    result
  }
  private def fixDataSourceNullTo20110209(connection: Connection): Boolean = {
    val md = connection.getMetaData()
    val statement = connection.createStatement()
    val sUserTable = addTablePrefix("USER")
    val sGroupTable = addTablePrefix("GROUP")
    val sStorageTable = addTablePrefix("STORAGE")
    val sFolderTable = addTablePrefix("FOLDER")
    val sFileTable = addTablePrefix("FILE")
    val sFileComponentTable = addTablePrefix("FILE_X_COMPONENT")
    val sUserGroupTable = addTablePrefix("USERGROUP")

    val version = selectRow(connection, "SELECT VALUE FROM METADATA WHERE KEY='VERSION'")(0).asInstanceOf[String]
    logger.info("update database from version " + version + " to 20110209")
    /*
     * STORAGE
     */
    if (!md.getTables(null, null, sStorageTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE " + sStorageTable + "\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2) NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"name\" VARCHAR_IGNORECASE(256) NOT NULL,\n"
      sCreateStatement += "\"service\" VARCHAR_IGNORECASE(256) NOT NULL,\n"
      sCreateStatement += "\"URL\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"owner_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT,\n"
      sCreateStatement += "\"last_user\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_time\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"created_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"updated_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"files_counter\" BIGINT DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"folders_counter\" BIGINT DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "UNIQUE (\"name\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sStorageTable))
        return false
      // add default storage
      val query = "INSERT INTO \"" + sStorageTable + "\" VALUES (1, '00000000-0000-0000-0000-000000000000',"+
                  "'default', 'org.digimead.documentumelasticus.storage.Storage', '', 1, NULL, 1, "+
                  "now, 'default storage', now, now, 0, 0, now)"
      try {
        statement.executeUpdate(query)
      } catch {
        case e => logger.error("error in SQL statement: " + query, e)
      }
    }
    /*
     * FOLDERS
     */
    if (!md.getTables(null, null, sFolderTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE " + sFolderTable + "\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2) NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"storage_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"path\" VARCHAR_IGNORECASE(4096) NOT NULL,\n"
      sCreateStatement += "\"service\" VARCHAR_IGNORECASE(256) NOT NULL,\n"
      sCreateStatement += "\"parent_id\" BIGINT,\n"
      sCreateStatement += "\"owner_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT,\n"
      sCreateStatement += "\"last_user\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_time\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"name\" VARCHAR(1024) NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"note\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"shared\" BOOLEAN DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"private\" BOOLEAN DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"permission\" BIGINT DEFAULT 511 NOT NULL,\n"
      sCreateStatement += "\"created_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"updated_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"files_counter\" INTEGER DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"folders_counter\" INTEGER DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"filter_mask\" VARCHAR_IGNORECASE(256),\n"
      sCreateStatement += "\"sort_type\" INTEGER DEFAULT 0 NOT NULL, \n"
      sCreateStatement += "\"sort_direction\" BOOLEAN DEFAULT 1 NOT NULL, \n"
      sCreateStatement += "\"display_order\" INTEGER DEFAULT 0 NOT NULL, \n"
      sCreateStatement += "\"undeletable\" BOOLEAN DEFAULT 0 NOT NULL, \n"
      sCreateStatement += "\"not_exists\" BOOLEAN DEFAULT 0 NOT NULL, \n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL, \n"
      sCreateStatement += "UNIQUE (\"path\", \"storage_id\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sFolderTable))
        return false
      // add default folder
      val query = "INSERT INTO \"" + sFolderTable + "\" VALUES (1, '00000000-0000-0000-0000-000000000000', \n" +
                  "1, '/', 'org.digimead.documentumelasticus.storage.Folder', NULL, 1, NULL, 1, now, \n" +
                  "'default folder', 'default folder', 'read only', 0, 0, 511, now, now, 0, 0, NULL, 0, 1, 0, 0, 1, now)"
      try {
        statement.executeUpdate(query)
      } catch {
        case e => logger.error("error in SQL statement: " + query, e)
      }
    }
    /*
     * FILES
     */
    if (!md.getTables(null, null, sFileTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE " + sFileTable + "\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2) NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"folder_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"name\" VARCHAR_IGNORECASE(4096) NOT NULL,\n"
      sCreateStatement += "\"service\" VARCHAR_IGNORECASE(256) NOT NULL,\n"
      sCreateStatement += "\"owner_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT,\n"
      sCreateStatement += "\"last_user\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_time\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"note\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"permission\" BIGINT DEFAULT 511 NOT NULL,\n"
      sCreateStatement += "\"created_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"updated_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"size\" BIGINT DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"mimetype\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"hash\" VARCHAR_IGNORECASE(1024) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"version\" BIGINT DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"readcounter\" BIGINT DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"writecounter\" BIGINT DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"display_order\" INTEGER DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"undeletable\" BOOLEAN DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"not_exists\" BOOLEAN DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "UNIQUE (\"name\", \"folder_id\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sFileTable))
        return false
      // add default file
      val query = "INSERT INTO \"" + sFileTable + "\" VALUES (1, '00000000-0000-0000-0000-000000000000', \n" +
                  "1, 'default file', 'org.digimead.documentumelasticus.storage.File', 1, NULL, 1, now, \n" +
                  "'default file', 'read only', 511, now, now, 0, '', '', 0, 0, 0, 0, 0, 1, now)"
      try {
        statement.executeUpdate(query)
      } catch {
        case e => logger.error("error in SQL statement: " + query, e)
      }
    }
    /*
     * FILES AVAILABLE PER COMPONENTS
     */
    if (!md.getTables(null, null, sFileComponentTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE " + sFileComponentTable + "\n"
      sCreateStatement += "(\"file_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"component\" VARCHAR_IGNORECASE(1024) NOT NULL,\n"
      sCreateStatement += "\"available\" BOOLEAN DEFAULT 0 NOT NULL,\n"
      sCreateStatement += "FOREIGN KEY (\"file_id\") REFERENCES \"" + sFileTable + "\"(\"id\"),\n"
      sCreateStatement += "UNIQUE (\"file_id\", \"component\"))"
      if (!createTable(connection, sCreateStatement, sFileComponentTable))
        return false
    }
    /*
     * USERS
     */
    if (!md.getTables(null, null, sUserTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE " + sUserTable + "\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2) NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"login\" VARCHAR_IGNORECASE(64) NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT,\n"
      sCreateStatement += "\"o\" VARCHAR_IGNORECASE(1024) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"givenname\" VARCHAR_IGNORECASE(1024) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"fathersname\" VARCHAR_IGNORECASE(1024) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"sn\" VARCHAR_IGNORECASE(1024) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"initials\" VARCHAR_IGNORECASE(2) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"apartment\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"street\" VARCHAR_IGNORECASE(1024) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"l\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"st\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"postalcode\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"c\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"title\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"position\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"homephone\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"telephonenumber\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"facsimiletelephonenumber\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"mail\" VARCHAR_IGNORECASE(256) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"avatar\" VARCHAR(32768) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "UNIQUE (\"login\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sUserTable))
        return false
      // add default user
      val query = "INSERT INTO \"" + sUserTable + "\" VALUES (1, '00000000-0000-0000-0000-000000000000', " +
                  "'anonymous', 1, 'unknown organization', " +
                  "'unknown givenname', 'unknown fathersname', " +
                  "'unknown surname', 'XX', 'unknown apartment', " +
                  "'unknown street', 'unknown city','unknown state', " +
                  "'unknown postalcode', 'unknown country', 'unknown title', " +
                  "'unknown position', 'unknown homephone', 'unknown mainphone', " +
                  "'unknown faxnumber', 'anonymous@none', '', now)"
      try {
        statement.executeUpdate(query)
      } catch {
        case e => logger.error("error in SQL statement: " + query, e)
      }
    }
    /*
     * GROUPS
     */
    if (!md.getTables(null, null, sGroupTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE \"" + sGroupTable + "\"\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2) NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"auc\" VARCHAR_IGNORECASE(1024) NOT NULL,\n"
      sCreateStatement += "\"parent_id\" BIGINT,\n"
      sCreateStatement += "\"name\" VARCHAR_IGNORECASE(64) NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"avatar\" VARCHAR(32768) DEFAULT '' NOT NULL, \n"
      sCreateStatement += "\"global\" BOOLEAN DEFAULT 0 NOT NULL, \n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "FOREIGN KEY (\"parent_id\") REFERENCES \"" + sGroupTable + "\"(\"id\"),\n"
      sCreateStatement += "UNIQUE (\"name\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sGroupTable))
        return false
      // add default group
      val query = "INSERT INTO \"" + sGroupTable + "\" VALUES (1, '00000000-0000-0000-0000-000000000000', " +
                  "'localhost', NULL, 'users', 'default group', '', 0, now)"
      try {
        statement.executeUpdate(query)
      } catch {
        case e => logger.error("error in SQL statement: " + query, e)
      }
    }
    if (!md.getTables(null, null, sUserGroupTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE " + sUserGroupTable + "\n"
      sCreateStatement += "(\"user_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096),\n"
      sCreateStatement += "PRIMARY KEY (\"user_id\", \"group_id\"),\n"
      sCreateStatement += "FOREIGN KEY (\"user_id\") REFERENCES \"" + sUserTable + "\"(\"id\"),\n"
      sCreateStatement += "FOREIGN KEY (\"group_id\") REFERENCES \"" + sGroupTable + "\"(\"id\"))"
      if (!createTable(connection, sCreateStatement, sUserGroupTable))
        return false
    }
    /*
     * ALTER USERS, add group fk
     */
    executeStatement(connection, "ALTER TABLE \"" + sUserTable + "\" ADD CONSTRAINT USER_GROUP_FK FOREIGN KEY (\"group_id\") REFERENCES  \"" + sGroupTable + "\"(\"id\")")
    /*
     * ALTER STORAGE, add user, group, ... fk
     */
    executeStatement(connection, "ALTER TABLE \"" + sStorageTable + "\" ADD CONSTRAINT STORAGE_OWNER_FK FOREIGN KEY (\"owner_id\") REFERENCES  \"" + sUserTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sStorageTable + "\" ADD CONSTRAINT STORAGE_LAST_USER_FK FOREIGN KEY (\"last_user\") REFERENCES  \"" + sUserTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sStorageTable + "\" ADD CONSTRAINT STORAGE_GROUP_FK FOREIGN KEY (\"group_id\") REFERENCES  \"" + sGroupTable + "\"(\"id\")")
    /*
     * ALTER FOLDER, ... fk
     */
    executeStatement(connection, "ALTER TABLE \"" + sFolderTable + "\" ADD CONSTRAINT FOLDER_STORAGE_FK FOREIGN KEY (\"storage_id\") REFERENCES  \"" + sStorageTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFolderTable + "\" ADD CONSTRAINT FOLDER_PARENT_FK FOREIGN KEY (\"parent_id\") REFERENCES  \"" + sFolderTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFolderTable + "\" ADD CONSTRAINT FOLDER_OWNER_FK FOREIGN KEY (\"owner_id\") REFERENCES  \"" + sUserTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFolderTable + "\" ADD CONSTRAINT FOLDER_LAST_USER_FK FOREIGN KEY (\"last_user\") REFERENCES  \"" + sUserTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFolderTable + "\" ADD CONSTRAINT FOLDER_GROUP_FK FOREIGN KEY (\"group_id\") REFERENCES  \"" + sGroupTable + "\"(\"id\")")
    /*
     * ALTER FILE, ... fk
     */
    executeStatement(connection, "ALTER TABLE \"" + sFileTable + "\" ADD CONSTRAINT FILE_FOLDER_FK FOREIGN KEY (\"folder_id\") REFERENCES  \"" + sFolderTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFileTable + "\" ADD CONSTRAINT FILE_OWNER_FK FOREIGN KEY (\"owner_id\") REFERENCES  \"" + sUserTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFileTable + "\" ADD CONSTRAINT FILE_LAST_USER_FK FOREIGN KEY (\"last_user\") REFERENCES  \"" + sUserTable + "\"(\"id\")")
    executeStatement(connection, "ALTER TABLE \"" + sFileTable + "\" ADD CONSTRAINT FILE_GROUP_FK FOREIGN KEY (\"group_id\") REFERENCES  \"" + sGroupTable + "\"(\"id\")")
    
    statement.executeUpdate("UPDATE METADATA SET VALUE='20110110' WHERE KEY='VERSION'")
    statement.close()
    true
  }
}
